{
  "address": "0x9155497EAE31D432C0b13dBCc0615a37f55a2c87",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IUniswapV2Pair",
          "name": "pairAddr",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenAddr",
          "type": "address"
        },
        {
          "internalType": "contract IDropsOracle",
          "name": "tokenOracleAddr",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "latestAnswer",
      "outputs": [
        {
          "internalType": "int256",
          "name": "answer",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pair",
      "outputs": [
        {
          "internalType": "contract IUniswapV2Pair",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tokenOracle",
      "outputs": [
        {
          "internalType": "contract IDropsOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x681503b90f7f813dc79f67588ab8f2c6113d84b70c409490f394654abb3a347c",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x9155497EAE31D432C0b13dBCc0615a37f55a2c87",
    "transactionIndex": 0,
    "gasUsed": "955613",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x18d34e4165abf20c1b6d97b8a37d95178ec7487855fa56b6f9e61eec40ebc833",
    "transactionHash": "0x681503b90f7f813dc79f67588ab8f2c6113d84b70c409490f394654abb3a347c",
    "logs": [],
    "blockNumber": 17536028,
    "cumulativeGasUsed": "955613",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x698AbbBC986C59D02941E18BC96fe2396493339B",
    "0x8d137e3337eb1B58A222Fef2B2Cc7C423903d9cf",
    "0xEbF67AB8cFF336D3F609127E8BbF8BD6DD93cd81"
  ],
  "solcInputHash": "2a79c4162b5952a6aa195452c697c39b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pairAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"contract IDropsOracle\",\"name\":\"tokenOracleAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOracle\",\"outputs\":[{\"internalType\":\"contract IDropsOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"latestAnswer()\":{\"details\":\"returns the latest price of asset\"}},\"title\":\"Price Aggreatofr for uniswap V2 LP tokens\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"latestAnswer()\":{\"notice\":\"we can reference LP pricing from https://blog.alphaventuredao.io/fair-lp-token-pricing/\"},\"pair()\":{\"notice\":\"address of Pair\"},\"token()\":{\"notice\":\"address of token that is not WETH\"},\"tokenOracle()\":{\"notice\":\"address of oracle for token ETH price\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracle/priceAggregators/UniV2LPPriceAggregator.sol\":\"UniV2LPPriceAggregator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0xb496651006b9a2a07920ffe116928b11e2a6458e21361cecca51409522488ca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"contracts/interfaces/drops/IDropsOracle.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol';\\n\\ninterface IDropsOracle {\\n    function latestAnswer() external view returns (int256);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x87e27a358f4eb0428b60bff5be5743ef7f794cba244c735f0e913cac26b66d0c\",\"license\":\"MIT\"},\"contracts/interfaces/uniswap/IUniswapV2Pair.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Pair {\\n    function totalSupply() external view returns (uint);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\",\"keccak256\":\"0x3e4a5dbcba1c33e3ce98f69297d4389e5e1ae070dc8451022da0bb03f8387ed5\",\"license\":\"MIT\"},\"contracts/lib/PRBMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explictly mentioned in the NatSpec documentation.\\n/// https://github.com/hifi-finance/prb-math\\n\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661508869554232690281;\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2 ** 128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2 ** 64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2 ** 32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2 ** 16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2 ** 8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2 ** 4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2 ** 2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2 ** 1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        require(SCALE > prod1);\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(\\n                            sub(prod1, gt(remainder, prod0)),\\n                            add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1)\\n                        )\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        require(x > type(int256).min);\\n        require(y > type(int256).min);\\n        require(denominator > type(int256).min);\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 resultUnsigned = mulDiv(ax, ay, ad);\\n        require(resultUnsigned <= uint256(type(int256).max));\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(resultUnsigned) : int256(resultUnsigned);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the closest power of two that is higher than x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8183430807b38057b9239bef75e1b858ae7ecdb6296690d56df3409b89abcb69\",\"license\":\"MIT\"},\"contracts/oracle/priceAggregators/UniV2LPPriceAggregator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport '../../lib/PRBMath.sol';\\nimport '../../interfaces/uniswap/IUniswapV2Pair.sol';\\nimport '../../interfaces/drops/IDropsOracle.sol';\\n\\n/**\\n * @title Price Aggreatofr for uniswap V2 LP tokens\\n */\\ncontract UniV2LPPriceAggregator {\\n    /// @notice WETH address\\n    address constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    /// @notice address of Pair\\n    IUniswapV2Pair public immutable pair;\\n\\n    /// @notice address of token that is not WETH\\n    address public immutable token;\\n\\n    /// @notice address of oracle for token ETH price\\n    IDropsOracle public immutable tokenOracle;\\n\\n    constructor(IUniswapV2Pair pairAddr, address tokenAddr, IDropsOracle tokenOracleAddr) {\\n        pair = pairAddr;\\n        token = tokenAddr;\\n        tokenOracle = tokenOracleAddr;\\n    }\\n\\n    /// @dev returns the latest price of asset\\n    /// @notice we can reference LP pricing from\\n    /// https://blog.alphaventuredao.io/fair-lp-token-pricing/\\n    function latestAnswer() external view returns (int256 answer) {\\n        (uint256 r0, uint256 r1, ) = pair.getReserves();\\n\\n        uint256 tokenReserve = pair.token0() == WETH ? r1 : r0;\\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\\n        if (tokenDecimals != 18) {\\n            tokenReserve = (tokenReserve * (10 ** 18)) / (10 ** (IERC20Metadata(token).decimals()));\\n        }\\n\\n        uint256 tokenETHPrice = uint256(tokenOracle.latestAnswer());\\n\\n        uint256 wethReserve = pair.token0() == WETH ? r0 : r1;\\n        uint256 r = PRBMath.sqrt(tokenReserve * wethReserve);\\n\\n        uint256 p = PRBMath.sqrt(tokenETHPrice * 1e18);\\n\\n        answer = int256((2 * r * p) / pair.totalSupply());\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n}\\n\",\"keccak256\":\"0xcda8982a58ec9ab8a212f3f506dcda2d9b5445c4517640663ea0d3fc379d9639\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b50604051620012d4380380620012d483398181016040528101906200003791906200012a565b8273ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff1660601b815250508173ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff1660601b815250508073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff1660601b815250505050506200022a565b600081519050620000f681620001dc565b92915050565b6000815190506200010d81620001f6565b92915050565b600081519050620001248162000210565b92915050565b6000806000606084860312156200014057600080fd5b6000620001508682870162000113565b93505060206200016386828701620000e5565b92505060406200017686828701620000fc565b9150509250925092565b60006200018d82620001bc565b9050919050565b6000620001a18262000180565b9050919050565b6000620001b58262000180565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b620001e78162000180565b8114620001f357600080fd5b50565b620002018162000194565b81146200020d57600080fd5b50565b6200021b81620001a8565b81146200022757600080fd5b50565b60805160601c60a05160601c60c05160601c611040620002946000396000818161042f01526106c40152600081816102b701528181610362015261070c015260008181610102015281816101f2015281816104fc015281816105f701526106e801526110406000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063313ce5671461005c57806350d25bcd1461007a5780636c5ec25c14610098578063a8aa1b31146100b6578063fc0c546a146100d4575b600080fd5b6100646100f2565b6040516100719190610c39565b60405180910390f35b6100826100fb565b60405161008f9190610c1e565b60405180910390f35b6100a06106c2565b6040516100ad9190610be8565b60405180910390f35b6100be6106e6565b6040516100cb9190610c03565b60405180910390f35b6100dc61070a565b6040516100e99190610bcd565b60405180910390f35b60006012905090565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b15801561016657600080fd5b505afa15801561017a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061019e9190610ae1565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b815260040160206040518083038186803b15801561025657600080fd5b505afa15801561026a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061028e9190610a8f565b73ffffffffffffffffffffffffffffffffffffffff16146102af57826102b1565b815b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561031b57600080fd5b505afa15801561032f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103539190610b59565b905060128160ff161461042b577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b1580156103c657600080fd5b505afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe9190610b59565b600a61040a9190610cd8565b670de0b6b3a76400008361041e9190610df6565b6104289190610c54565b91505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561049357600080fd5b505afa1580156104a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104cb9190610ab8565b9050600073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b815260040160206040518083038186803b15801561056057600080fd5b505afa158015610574573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105989190610a8f565b73ffffffffffffffffffffffffffffffffffffffff16146105b957846105bb565b855b905060006105d382866105ce9190610df6565b61072e565b905060006105f3670de0b6b3a7640000856105ee9190610df6565b61072e565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561065b57600080fd5b505afa15801561066f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106939190610b30565b818360026106a19190610df6565b6106ab9190610df6565b6106b59190610c54565b9850505050505050505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000808214156107415760009050610a0c565b600082905060019150700100000000000000000000000000000000811061077157608081901c9050604082901b91505b68010000000000000000811061079057604081901c9050602082901b91505b64010000000081106107ab57602081901c9050601082901b91505b6201000081106107c457601081901c9050600882901b91505b61010081106107dc57600881901c9050600482901b91505b601081106107f357600481901c9050600282901b91505b6008811061080357600182901b91505b600182848161083b577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c9150600182848161087a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816108b9577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816108f8577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c91506001828481610937577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c91506001828481610976577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816109b5577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060008284816109f4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b04905080831015610a055782610a07565b805b925050505b919050565b600081519050610a2081610f80565b92915050565b600081519050610a3581610f97565b92915050565b600081519050610a4a81610fae565b92915050565b600081519050610a5f81610fc5565b92915050565b600081519050610a7481610fdc565b92915050565b600081519050610a8981610ff3565b92915050565b600060208284031215610aa157600080fd5b6000610aaf84828501610a11565b91505092915050565b600060208284031215610aca57600080fd5b6000610ad884828501610a26565b91505092915050565b600080600060608486031215610af657600080fd5b6000610b0486828701610a3b565b9350506020610b1586828701610a3b565b9250506040610b2686828701610a65565b9150509250925092565b600060208284031215610b4257600080fd5b6000610b5084828501610a50565b91505092915050565b600060208284031215610b6b57600080fd5b6000610b7984828501610a7a565b91505092915050565b610b8b81610e50565b82525050565b610b9a81610ecd565b82525050565b610ba981610ef1565b82525050565b610bb881610e62565b82525050565b610bc781610ec0565b82525050565b6000602082019050610be26000830184610b82565b92915050565b6000602082019050610bfd6000830184610b91565b92915050565b6000602082019050610c186000830184610ba0565b92915050565b6000602082019050610c336000830184610baf565b92915050565b6000602082019050610c4e6000830184610bbe565b92915050565b6000610c5f82610ea6565b9150610c6a83610ea6565b925082610c7a57610c79610f44565b5b828204905092915050565b6000808291508390505b6001851115610ccf57808604811115610cab57610caa610f15565b5b6001851615610cba5780820291505b8081029050610cc885610f73565b9450610c8f565b94509492505050565b6000610ce382610ea6565b9150610cee83610ec0565b9250610d1b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484610d23565b905092915050565b600082610d335760019050610def565b81610d415760009050610def565b8160018114610d575760028114610d6157610d90565b6001915050610def565b60ff841115610d7357610d72610f15565b5b8360020a915084821115610d8a57610d89610f15565b5b50610def565b5060208310610133831016604e8410600b8410161715610dc55782820a905083811115610dc057610dbf610f15565b5b610def565b610dd28484846001610c85565b92509050818404811115610de957610de8610f15565b5b81810290505b9392505050565b6000610e0182610ea6565b9150610e0c83610ea6565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610e4557610e44610f15565b5b828202905092915050565b6000610e5b82610e86565b9050919050565b6000819050919050565b60006dffffffffffffffffffffffffffff82169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600063ffffffff82169050919050565b600060ff82169050919050565b6000610ed882610edf565b9050919050565b6000610eea82610e86565b9050919050565b6000610efc82610f03565b9050919050565b6000610f0e82610e86565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008160011c9050919050565b610f8981610e50565b8114610f9457600080fd5b50565b610fa081610e62565b8114610fab57600080fd5b50565b610fb781610e6c565b8114610fc257600080fd5b50565b610fce81610ea6565b8114610fd957600080fd5b50565b610fe581610eb0565b8114610ff057600080fd5b50565b610ffc81610ec0565b811461100757600080fd5b5056fea2646970667358221220f98ac70d41aa8492e88dcde3003bb1211a60a165b5f0f767941aaff794aa905064736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063313ce5671461005c57806350d25bcd1461007a5780636c5ec25c14610098578063a8aa1b31146100b6578063fc0c546a146100d4575b600080fd5b6100646100f2565b6040516100719190610c39565b60405180910390f35b6100826100fb565b60405161008f9190610c1e565b60405180910390f35b6100a06106c2565b6040516100ad9190610be8565b60405180910390f35b6100be6106e6565b6040516100cb9190610c03565b60405180910390f35b6100dc61070a565b6040516100e99190610bcd565b60405180910390f35b60006012905090565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b15801561016657600080fd5b505afa15801561017a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061019e9190610ae1565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff169150600073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b815260040160206040518083038186803b15801561025657600080fd5b505afa15801561026a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061028e9190610a8f565b73ffffffffffffffffffffffffffffffffffffffff16146102af57826102b1565b815b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561031b57600080fd5b505afa15801561032f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103539190610b59565b905060128160ff161461042b577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b1580156103c657600080fd5b505afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe9190610b59565b600a61040a9190610cd8565b670de0b6b3a76400008361041e9190610df6565b6104289190610c54565b91505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561049357600080fd5b505afa1580156104a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104cb9190610ab8565b9050600073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff167f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b815260040160206040518083038186803b15801561056057600080fd5b505afa158015610574573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105989190610a8f565b73ffffffffffffffffffffffffffffffffffffffff16146105b957846105bb565b855b905060006105d382866105ce9190610df6565b61072e565b905060006105f3670de0b6b3a7640000856105ee9190610df6565b61072e565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561065b57600080fd5b505afa15801561066f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106939190610b30565b818360026106a19190610df6565b6106ab9190610df6565b6106b59190610c54565b9850505050505050505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000808214156107415760009050610a0c565b600082905060019150700100000000000000000000000000000000811061077157608081901c9050604082901b91505b68010000000000000000811061079057604081901c9050602082901b91505b64010000000081106107ab57602081901c9050601082901b91505b6201000081106107c457601081901c9050600882901b91505b61010081106107dc57600881901c9050600482901b91505b601081106107f357600481901c9050600282901b91505b6008811061080357600182901b91505b600182848161083b577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c9150600182848161087a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816108b9577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816108f8577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c91506001828481610937577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c91506001828481610976577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060018284816109b5577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b048301901c915060008284816109f4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b04905080831015610a055782610a07565b805b925050505b919050565b600081519050610a2081610f80565b92915050565b600081519050610a3581610f97565b92915050565b600081519050610a4a81610fae565b92915050565b600081519050610a5f81610fc5565b92915050565b600081519050610a7481610fdc565b92915050565b600081519050610a8981610ff3565b92915050565b600060208284031215610aa157600080fd5b6000610aaf84828501610a11565b91505092915050565b600060208284031215610aca57600080fd5b6000610ad884828501610a26565b91505092915050565b600080600060608486031215610af657600080fd5b6000610b0486828701610a3b565b9350506020610b1586828701610a3b565b9250506040610b2686828701610a65565b9150509250925092565b600060208284031215610b4257600080fd5b6000610b5084828501610a50565b91505092915050565b600060208284031215610b6b57600080fd5b6000610b7984828501610a7a565b91505092915050565b610b8b81610e50565b82525050565b610b9a81610ecd565b82525050565b610ba981610ef1565b82525050565b610bb881610e62565b82525050565b610bc781610ec0565b82525050565b6000602082019050610be26000830184610b82565b92915050565b6000602082019050610bfd6000830184610b91565b92915050565b6000602082019050610c186000830184610ba0565b92915050565b6000602082019050610c336000830184610baf565b92915050565b6000602082019050610c4e6000830184610bbe565b92915050565b6000610c5f82610ea6565b9150610c6a83610ea6565b925082610c7a57610c79610f44565b5b828204905092915050565b6000808291508390505b6001851115610ccf57808604811115610cab57610caa610f15565b5b6001851615610cba5780820291505b8081029050610cc885610f73565b9450610c8f565b94509492505050565b6000610ce382610ea6565b9150610cee83610ec0565b9250610d1b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484610d23565b905092915050565b600082610d335760019050610def565b81610d415760009050610def565b8160018114610d575760028114610d6157610d90565b6001915050610def565b60ff841115610d7357610d72610f15565b5b8360020a915084821115610d8a57610d89610f15565b5b50610def565b5060208310610133831016604e8410600b8410161715610dc55782820a905083811115610dc057610dbf610f15565b5b610def565b610dd28484846001610c85565b92509050818404811115610de957610de8610f15565b5b81810290505b9392505050565b6000610e0182610ea6565b9150610e0c83610ea6565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610e4557610e44610f15565b5b828202905092915050565b6000610e5b82610e86565b9050919050565b6000819050919050565b60006dffffffffffffffffffffffffffff82169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600063ffffffff82169050919050565b600060ff82169050919050565b6000610ed882610edf565b9050919050565b6000610eea82610e86565b9050919050565b6000610efc82610f03565b9050919050565b6000610f0e82610e86565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008160011c9050919050565b610f8981610e50565b8114610f9457600080fd5b50565b610fa081610e62565b8114610fab57600080fd5b50565b610fb781610e6c565b8114610fc257600080fd5b50565b610fce81610ea6565b8114610fd957600080fd5b50565b610fe581610eb0565b8114610ff057600080fd5b50565b610ffc81610ec0565b811461100757600080fd5b5056fea2646970667358221220f98ac70d41aa8492e88dcde3003bb1211a60a165b5f0f767941aaff794aa905064736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "latestAnswer()": {
        "details": "returns the latest price of asset"
      }
    },
    "title": "Price Aggreatofr for uniswap V2 LP tokens",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "latestAnswer()": {
        "notice": "we can reference LP pricing from https://blog.alphaventuredao.io/fair-lp-token-pricing/"
      },
      "pair()": {
        "notice": "address of Pair"
      },
      "token()": {
        "notice": "address of token that is not WETH"
      },
      "tokenOracle()": {
        "notice": "address of oracle for token ETH price"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}